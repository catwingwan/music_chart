# music_chart_mvp.py
# MVP: è‡ªå‹•å»ºç«‹æ­Œæ›²æ’è¡Œæ¦œï¼Œç”Ÿæˆ HTMLï¼Œä¸¦è‡ªå‹•ç™¼ä½ˆåˆ° Bloggerï¼ˆå« AI è§£èªªæ®µè½ï¼‰

import requests
import pandas as pd
import urllib.parse
from dotenv import load_dotenv
import os
import json
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build

# === è¼‰å…¥ç’°å¢ƒè®Šæ•¸ ===
load_dotenv()

# === CONFIG ===
SPOTIFY_CLIENT_ID = os.getenv("SPOTIFY_CLIENT_ID") or "YOUR_SPOTIFY_CLIENT_ID"
SPOTIFY_CLIENT_SECRET = os.getenv("SPOTIFY_CLIENT_SECRET") or "YOUR_SPOTIFY_CLIENT_SECRET"
YOUTUBE_API_KEY = os.getenv("YOUTUBE_API_KEY") or "YOUR_YOUTUBE_API_KEY"
TOKEN_PATH = "token.json"

# === å‹•æ…‹å–å¾— Spotify æ–°æ­Œæ¦œå–® ===
def fetch_spotify_new_releases(token, limit=10):
    url = f"https://api.spotify.com/v1/browse/new-releases?limit={limit}"
    headers = {"Authorization": f"Bearer {token}"}
    resp = requests.get(url, headers=headers)
    albums = resp.json().get("albums", {}).get("items", [])
    songs = []
    for album in albums:
        name = album['name']
        artists = ", ".join([artist['name'] for artist in album['artists']])
        songs.append({"æ­Œæ›²åç¨±": name, "æ­Œæ‰‹": artists})
    return songs

# === Spotify æˆæ¬Š ===
def get_spotify_token():
    resp = requests.post("https://accounts.spotify.com/api/token",
        data={"grant_type": "client_credentials"},
        auth=(SPOTIFY_CLIENT_ID, SPOTIFY_CLIENT_SECRET))
    return resp.json().get("access_token")

# === æŸ¥ Spotify ç†±åº¦ ===
def fetch_spotify_popularity(song, artist, token):
    from datetime import datetime
    week_str = datetime.now().strftime("%Y-%W")
    log_path = f"logs/error_log_{week_str}.txt"
    with open(log_path, "a", encoding="utf-8") as log:
        query = urllib.parse.quote(f"track:{song} artist:{artist}")
        url = f"https://api.spotify.com/v1/search?q={query}&type=track&limit=1"
        headers = {"Authorization": f"Bearer {token}"}
        resp = requests.get(url, headers=headers)
        items = resp.json().get("tracks", {}).get("items", [])
        if items:
            return items[0]["popularity"]
        print(f"âš  æ‰¾ä¸åˆ° Spotify ç†±åº¦ï¼š{song} - {artist}")
        log.write(f"No Spotify popularity found for: {song} - {artist}\\n")
        return 0

# === æŸ¥ YouTube æ’­æ”¾é‡ ===
def fetch_youtube_views(song, artist):
    from datetime import datetime
    week_str = datetime.now().strftime("%Y-%W")
    log_path = f"logs/error_log_{week_str}.txt"
    with open(log_path, "a", encoding="utf-8") as log:
        query = urllib.parse.quote(f"{song} {artist}")
        search_url = f"https://www.googleapis.com/youtube/v3/search?part=snippet&q={query}&key={YOUTUBE_API_KEY}&maxResults=1&type=video"
        resp = requests.get(search_url).json()
        items = resp.get("items", [])
        if not items:
            print(f"âš  æ‰¾ä¸åˆ°å½±ç‰‡ï¼š{song} - {artist}")
            log.write(f"No video found for: {song} - {artist}\\n")
            return 0
        video_id = items[0].get("id", {}).get("videoId")
        if not video_id:
            return 0
        stat_url = f"https://www.googleapis.com/youtube/v3/videos?part=statistics&id={video_id}&key={YOUTUBE_API_KEY}"
        stats = requests.get(stat_url).json()
        if "items" not in stats or not stats["items"]:
            return 0
        views = stats["items"][0]["statistics"].get("viewCount", 0)
        return int(views)

# === æ•´åˆè³‡æ–™èˆ‡æ’åº ===
def build_chart():
    token = get_spotify_token()
    songs = fetch_spotify_new_releases(token, limit=10)
    chart = []
    for song in songs:
        yt_views = fetch_youtube_views(song['æ­Œæ›²åç¨±'], song['æ­Œæ‰‹'])
        spotify_pop = fetch_spotify_popularity(song['æ­Œæ›²åç¨±'], song['æ­Œæ‰‹'], token)
        score = (yt_views / 1000) * 0.5 + spotify_pop * 0.5
        chart.append({
            "æ­Œæ›²": song['æ­Œæ›²åç¨±'],
            "æ­Œæ‰‹": song['æ­Œæ‰‹'],
            "YTæ’­æ”¾é‡": yt_views,
            "Spotifyç†±åº¦": spotify_pop,
            "ç¸½åˆ†": round(score, 2),
            "Spotifyé€£çµ": f"https://open.spotify.com/search/{urllib.parse.quote(song['æ­Œæ›²åç¨±'] + ' ' + song['æ­Œæ‰‹'])}"
        })
    df = pd.DataFrame(chart)
    df["æ’å"] = df["ç¸½åˆ†"].rank(ascending=False, method="min").astype(int)
    return df.sort_values("æ’å")

# === ç”¢ç”Ÿ HTML è¡¨æ ¼ ===
def generate_html_table(df):
    html = '''
    <h2>ğŸ”¥ æœ¬é€±æ­Œæ›²æ’è¡Œæ¦œ</h2>
    <table border="1" cellpadding="8" cellspacing="0" style="border-collapse:collapse;width:100%;text-align:center;">
        <thead>
            <tr>
                <th>æ’å</th>
                <th>æ­Œæ›²</th>
                <th>æ­Œæ‰‹</th>
                <th>YouTube æ’­æ”¾é‡</th>
                <th>Spotify ç†±åº¦</th>
                <th>ç¸½åˆ†</th>
                <th>Spotify</th>
            </tr>
        </thead>
        <tbody>
    '''
    for _, row in df.iterrows():
        html += f"""
        <tr>
            <td>{row['æ’å']}</td>
            <td>{row['æ­Œæ›²']}</td>
            <td>{row['æ­Œæ‰‹']}</td>
            <td>{row['YTæ’­æ”¾é‡']:,}</td>
            <td>{row['Spotifyç†±åº¦']}</td>
            <td>{row['ç¸½åˆ†']}</td>
            <td><a class='spotify' href='{row['Spotifyé€£çµ']}' target='_blank'>ğŸ§</a></td>
        </tr>
        """
    html += '</tbody></table>'
    return html

# === ç”¢ç”Ÿ AI è§£èªªæ®µè½ï¼ˆç°¡åŒ–ï¼‰ ===
def generate_ai_summary(df):
    top1 = df.iloc[0]
    top3 = df.head(3)
    song_list = ", ".join([f"ã€Š{row['æ­Œæ›²']}ã€‹ by {row['æ­Œæ‰‹']}" for _, row in top3.iterrows()])
    summary = (
        f"This week's top 3 songs are: {song_list}. "
        f"#1 is ã€Š{top1['æ­Œæ›²']}ã€‹ by {top1['æ­Œæ‰‹']} with a total score of {top1['ç¸½åˆ†']}. "
        f"Momentum remains strong for Mandarin pop!"
    )
    return summary

# === è‡ªå‹•ç™¼ä½ˆåˆ° Bloggerï¼Œæ”¯æ´ token.json å¿«å–æˆæ¬Š ===
def publish_to_blogger(html_content, title="MACP Music Chart"):
    SCOPES = ['https://www.googleapis.com/auth/blogger']
    creds = None
    if os.path.exists(TOKEN_PATH):
        creds = Credentials.from_authorized_user_file(TOKEN_PATH, SCOPES)
    if not creds or not creds.valid:
        flow = InstalledAppFlow.from_client_secrets_file('client_secret.json', SCOPES)
        creds = flow.run_local_server(port=8080)
        with open(TOKEN_PATH, 'w') as token:
            token.write(creds.to_json())

    service = build('blogger', 'v3', credentials=creds)

    # å–å¾—ä½¿ç”¨è€…éƒ¨è½æ ¼ ID
    blogs = service.blogs().listByUser(userId='self').execute()
    blog_id = blogs['items'][0]['id']

    # ç™¼ä½ˆæ–°æ–‡ç« 
    post = {
        'title': title,
        'content': html_content
    }
    response = service.posts().insert(blogId=blog_id, body=post, isDraft=False).execute()
    print(f"âœ” å·²ç™¼ä½ˆæ–‡ç« ï¼š{response.get('title')}")
    print(f"ğŸ”— ç¶²å€ï¼š{response.get('url')}")

# === ä¸»ç¨‹å¼åŸ·è¡Œ ===
if __name__ == "__main__":
    os.makedirs("logs", exist_ok=True)
    chart_df = build_chart()
    summary = generate_ai_summary(chart_df)
    html_output = f"<p>{summary}</p>\n" + generate_html_table(chart_df)

    # å¯«å…¥æœ¬åœ°æª”æ¡ˆï¼ˆå¯é¸ï¼‰
    with open("ranking_output.html", "w", encoding="utf-8") as f:
        f.write(html_output)
    print("âœ” æ’è¡Œæ¦œå·²ç”¢å‡ºï¼ˆå« AI è§£èªªæ®µè½ï¼‰")

    # è‡ªå‹•ç™¼ä½ˆåˆ° Blogger
    publish_to_blogger(html_output, title="MACP æœ¬é€±æ­Œæ›²æ•¸æ“šæ¦œ")
